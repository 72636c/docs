# Deploying to ECS

<%= estimated_time "30 minutes" %>

{:toc}

This tutorial demonstrates how to deploy a Docker image to Amazon Elastic Container Service (ECS) using Buildkite best practices.

We'll use one pipeline to run tests and push a Docker image to a registry (the test pipeline).
We'll use another to deploy the resulting Docker image to ECS using the [ECS Deploy Buildkite Plugin](https://github.com/buildkite-plugins/ecs-deploy-buildkite-plugin).
Finally, we'll link the two pipelines together so that commits to your master branch are automatically deployed to ECS.

## Push a Docker image

If you already have build process that pushes a Docker image to a registry, you can use that instead of the following NGINX example.

Before pushing your Docker image to a registry you'll need to authenticate the Agent with the registry.

This Dockerfile creates a tiny Docker image that serves the [NGINX](https://www.nginx.com/) docs on port 80.

TODO we could switch this out to serve a Buildkite themed static page

```
FROM nginx:alpine
```
{: codeblock-file="Dockerfile"}


1. Create the pipeline

TODO figure out some command specifics

TODO are we going to host this on

```
# Build image

# Push to registry
```
{: codeblock-file=".buildkite/pipeline.deploy.yml"}

## Configure ECS

1. Install [aws cli](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_CLI_installation.html) on the agent.

2. Grant the following [permissions](https://github.com/buildkite-plugins/ecs-deploy-buildkite-plugin#aws-roles) to the Buildkite agent:

    ```
    Policy:
      Statement:
      - Action:
        - ecr:DescribeImages
        - ecs:DescribeServices
        - ecs:RegisterTaskDefinition
        - ecs:UpdateService
        - ecs:CreateService
        Effect: Allow
        Resource: '*'
    ```

## Deploy to ECS

The ECS Deploy Buildkite Plugin uses a json task definition to define some cluster settings:

```
[
    {
        "essential": true,
        "image": "amazon/amazon-ecs-sample",
        "memory": 100,
        "name": "buildkite-deploy-example",
        "portMappings": [
            {
                "containerPort": 80,
                "hostPort": 80
            }
        ]
    }
]
```
{: codeblock-file="ecs-task-definition.json"}

The plugin will create the cluster if it doesn't already exist, so as long as the agent has the permissions mentioned in [Configure CS](#configure-ecs), you can create a deploy pipeline.

1. Create a new pipeline. Enter `buildkite-agent pipeline upload .buildkite/pipeline.deploy.yml` in the commands to run field.

     <%= image "new_pipeline.png", width: 1440/2, height: 820/2, alt: 'Creating a New Pipeline'  %>

2. Create `.buildkite/pipeline.deploy.yml`:

    ```yml
    steps:
      - label: ":ecs: :rocket:"
        concurrency_group: "my-service-deploy"
        concurrency: 1
        plugins:
          - ecs-deploy#v1.4.1:
              cluster: "my-ecs-cluster"
              service: "my-service"
              task-definition: "examples/hello-world.json"
              task-family: "hello-world"
              image: "${ECR_REPOSITORY}/hello-world:${BUILDKITE_BUILD_NUMBER}"
    ```
    {: codeblock-file="pipeline.deploy.yml"}

   Set [`concurrency` and `concurrency_group`](/docs/pipelines/controlling-concurrency#concurrency-limits) when updating mutable state to ensure that only one step runs at a time.


## Test the Pipeline

<!-- TODO how do we pass the image? locally? Or just rely on the registry

Open the deployment pipline and click "New Build". Click "Options" and set the
`DOCKER_IMAGE` environment variable.

<%= image "manual_deployment.png", width: 1440/2, height: 780/2, alt: "New Manual Build" %>

-->

<%= image "deploy_step.png", alt: "Deploy Step" %>

Note the public IP in the "Ports" column. That IP points to the sample
applications. Open it in your browser.

## Continuous Deployment

We'll use a [trigger step](https://buildkite.com/docs/pipelines/trigger-step)
to connect the test and deploy pipelines.

TODO why does the wait affect these?

1. Add a wait step at the end of `.buildkite/build-pipeline.yml` to prevent deploys triggering at the wrong time or for failed builds.

    ```yml
      # Add a wait step to only deploy after all steps complete
      - wait
    ```

2. Next add a `trigger` step:

```yml
  - label: ':rocket: Deploy'
    # TODO: replace with your deploy pipeline's name
    trigger: ecs-deploy-tutorial
    # Only trigger on master build
    branches: master
    build:
      message: "${BUILDKITE_MESSAGE}"
      commit: "${BUILDKITE_COMMIT}"
      branch: "${BUILDKITE_BRANCH}"
      env:
        # TODO: replace with your Docker image name
        DOCKER_IMAGE: "sample/buildkite-ecs-tutorial:${BUILDKITE_BUILD_NUMBER}"
```

This `trigger` step creates a build with the same message, commit, and branch.
`buildkite-agent pipeline-upload` interpolates environment variables so the
correct values are replaced when the pipeline starts. The `env` setting passes
along the `DOCKER_IMAGE` environment variable.

Lastly, the `branches` options indicates to only build on `master`. This
prevents deploying unexpected topic branches.

It's magic time. Push some code. :tada: Continuous deployment! You'll see the
`ecs-cli` updating the services and tasks accordingly.

<%= image "final_test_pipeline.png", width: 1440/2, height: 430/2, alt: 'Final Test Pipeline' %>

## Next Steps

Congratulations! :tada: You've setup a continuous deployment pipeline to
ECS. Practically speaking there are some things to do next.

- Try a [block step](https://buildkite.com/docs/pipelines/block-step) before the
  trigger to enforce manual deploys.
- Use [Github's Deployment API](https://buildkite.com/blog/github-deployments)
  to trigger deployments from external tooling (i.e. ChatOps)

[guide]: https://aws.amazon.com/ecs/getting-started/
[ecs-wizard]: https://console.aws.amazon.com/ecs/home?region=us-east-1#/firstRun

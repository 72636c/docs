# Importing JUnit XML

<div class="Docs__wip-note">
<p class="Docs__wip-heading">Test Analytics is an invite-only beta feature. Join the <a href="https://buildkite.com/test-analytics">waitlist</a>.</p>
</div>

You can use the Test Analytics API to upload JUnit XML.

{:toc}

While most test frameworks can export JUnit XML, these reports do not provide detailed span information.
Therefore, analytics that depend on span information aren't available when using JUnit as a data source.
If you need span information, consider [importing JSON](/docs/test-analytics/importing-json) instead.

## How to import JUnit XML

To import JUNit XML, you can either:

- [Use the `collect.sh` convenience script](#import-junit-xml-using-collect-dot-sh) to read test results, build a request, and upload to the REST API.
- [Make a POST request to `https://analytics-api.buildkite.com/v1/uploads`](#import-junit-xml-using-the-api), with metadata and JUnit XML test results encoded as JSON in the request body.

## Import JUnit XML using `collect.sh`

[`collect.sh`](https://github.com/buildkite/collector-junit/blob/HEAD/collect.sh) uploads JUnit XML and continuous integration environment metadata to Buildkite.
`collect.sh` accepts JUnit XML as standard input and detects continuous integration environment variables from Buildkite, CircleCI, and GitHub Actions.

To run, `collect.sh` requires:

- Bash
- curl
- [jq](https://stedolan.github.io/jq/)
  (if `jq` is not installed, `collect.sh` downloads it automatically, but you can avoid the delay by installing jq ahead of time)

To use `collect.sh`, [securely export the Test Analytics token environment variable](/docs/pipelines/secrets) (`TEST_ANALYTICS_TOKEN`) to your environment and stream JUnit XML to the script's standard input.
For example, this command downloads the `collect.sh` script and uses it to upload the contents of the file `junit.xml`:

```bash
cat "junit.xml" | \
  bash -c "$(curl -sL https://raw.githubusercontent.com/buildkite/collector-junit/HEAD/collect.sh)"
```

## Import JUnit XML using the API

To import JUnit XML with the API, make a POST request to `https://analytics-api.buildkite.com/v1/uploads`, with metadata and JUnit XML test results encoded as JSON in the request body.

For example, to a `curl` command to upload:

- [Securely export the Test Analytics token environment variable](/docs/pipelines/secrets) (`TEST_ANALYTICS_TOKEN`) to your environment.
- Set environment variables for the `run_env` JSON object (see [Environment variables](#environment-variables) for details). This example uses the Buildkite pipeline environment variables.
- Escape the JUnit XML to a JSON string.

Then run `curl` like this, where `"JUnit XML goes here"` is the JSON-escaped string:

```sh
curl --request POST \
  --url https://analytics-api.buildkite.com/v1/uploads \
  --header 'Authorization: Token token="'$TEST_ANALYTICS_TOKEN'";' \
  --header 'Content-Type: application/json' \
  --data @- << EOF
    {
      "format": "junit",
      "run_env": {
        "CI": "buildkite",
        "key": "$BUILDKITE_BUILD_ID",
        "number": "$BUILDKITE_BUILD_NUMBER",
        "job_id": "$BUILDKITE_JOB_ID",
        "branch": "$BUILDKITE_BRANCH",
        "commit_sha": "$BUILDKITE_COMMIT",
        "message": "$BUILDKITE_MESSAGE",
        "url": "$BUILDKITE_BUILD_URL"
      },
      "data": "JUnit XML goes here"
    }
EOF
```

By making the API request, Test Analytics parses the XML and imports all valid test cases for ingestion and valuation. The response to a successful request is `202 Accepted` with the newly created `id` (Run ID), and totals for the number of `queued` and `skipped` test cases contained in the uploaded data.

```json
{
  "id": "eac9b176-7869-464d-952e-7f87e2579128",
  "queued": 3,
  "skipped": 0
}
```

Note that when a payload is processed, Buildkite validates and queues each test execution result in a loop. For that reason, it is possible for some to be queued and others to be skipped. Even when some or all test executions get skipped, REST API will respond with a `202 Accepted` because the upload and the run were created in the database, but the skipped test execution results were not ingested.

Currently, the errors returned contain no information on individual records that failed the validation. This may make complicate the process of fixing and retrying the request.

## Environment variables

Test Analytics uses environment variables to populate test information. In the most common case, [RSpec collector](/docs/test-analytics/ruby-collectors#rspec-collector) is used and, regardless of the CI provider you use to run your builds, you'd need to make sure that environment variables are available to RSpec or import API. You'd also need to make sure that the environment variables are passed through to a container if your builds are running in containers.

But if you're using such tools as the JUnit or [JSON](/docs/test-analytics/importing-json) importers, you need to configure the variables in `run_env` yourself.

The only required variable is `key`, but some features of Test Analytics aren't available if the other variables are not set:

| Variable     | Description                                                    |
|--------------|----------------------------------------------------------------|
| `key`        | a unique key for the build that initiated the Test Analytics run |
| `url`        | URL that links to the build                                    |
| `branch`     | the branch or reference that this run is for                         |
| `commit_sha` | the commit SHA for the head of the branch                      |
| `number`     | the build number of the build                                  |
| `job_id`     | the id of a job within the build                               |
| `message`    | the commit message for the head of the branch                  |

# Group Step
 
A *group* step groups jobs and steps like block step, trigger step, comand step, etc. into logical groups, and allows displaying them within groups on the build page in the Buildkite UI.

> Note: Group steps cannot be nested. 

You can scale your build pipelines in Buildkite to support an unlimited number of jobs. However, a large number of jobs on the build page can look messy. If pipelines contain 4-5 steps that can be logically grouped together, you can put them in a group using the `group` step type.

The group step also helps manage dependencies between a collection of steps in a DAG (for example, step X depends on everything in a group Y).

> Note: In some cases, using group step might break the DAG visualisation feature.  

{:toc}
 
A group step can be defined in your pipeline settings, or in your [pipeline.yml](/docs/pipelines/defining-steps) file.  

```yml
steps:
   - group: "Various Grouped Jobs"
                steps:
                - command: "test.sh"
                - wait: ~
                - trigger: "#{project.slug}"
                  label: "Deploy"
```
{: codeblock-file="pipeline.yml"}

This is what a typical group step use looks like:

```yml
- group: ":broom: Linting"
  key: "linting"
  depends_on: docker
  steps:
    - name: ":rubocop: RuboCop"
      command: ".buildkite/steps/rubocop"
    - name: ":eslint: ESlint"
      command: ".buildkite/steps/eslint"
    - name: ":flowtype: Flow"
      command: ".buildkite/steps/flow"
```

And this is how it's displayed in the UI: 

<%= image "job-groups-in-UI.png", width: 1760, height: 436, alt: "Job groups displayed in the Buildkite UI" %>

## Group step attributes  

_Step attributes:_  

<table data-attributes>
  <tr>
    <td><code>allow_dependency_failure</code></td>
    <td>
      Whether to continue to run this step if any of the steps named in the <code>depends_on</code> attribute fail.<br>
      <em>Default:</em> <code>false</code>
    </td>
  </tr>
  <tr>
    <td><code>branches</code></td>
    <td>
      The <a href="/docs/pipelines/branch-configuration#branch-pattern-examples">branch pattern</a> defining which branches will include this step in their builds.<br>
      <em>Example:</em> <code>"main stable/*"</code>
    </td>
  </tr>
  <tr>
    <td><code>depends_on</code></td>
    <td>
      A list of step keys that this step depends on. This step will only run after the named steps have completed. See <a href="/docs/pipelines/dependencies">managing step dependencies</a> for more information.<br>
      <em>Example:</em> <code>"test-suite"</code>
    </td>
   </tr>
  <tr>
    <td><code>env</code></td>
    <td>
      A map of <a href="/docs/pipelines/environment-variables">environment variables</a> for this step.<br>
      <em>Example:</em> <code>RAILS_ENV: "test"</code>
    </td>
  </tr>
  <tr>
    <td><code>if</code></td>
    <td>
      A boolean expression that omits the step when false. See <a href="/docs/pipelines/conditionals">Using conditionals</a> for supported expressions.<br>
      <em>Example:</em> <code>build.message != "skip me"</code>
    </td>
  </tr>
  <tr>
    <td><code>key</code></td>
    <td>
	A unique string to identify the block step.
      <em>Example:</em> <code>"test-suite"</code>
    </td>
  </tr>  
  <tr>
    <td><code>label</code></td>
    <td>
      The label that will be displayed in the pipeline visualisation in Buildkite. Supports emoji.<br>
      <em>Example:</em> <code>"\:hammer\: Tests" will be rendered as "ðŸ”¨: Tests"</code><br>
    </td>
  </tr>
  <tr>
    <td><code>notify</code></td>
    <td>
      Notify attribute description.<br>
      <em>Example:</em> <code>Example</code><br>
    </td>
  </tr>
  <tr>
    <td><code>skip</code></td>
    <td>
      Whether to skip this step or not. Passing a string provides a reason for skipping this command. Passing an empty string is equivalent to <code>false</code>.
      Note: Skipped steps will be hidden in the pipeline view by default, but can be made visible by toggling the 'Skipped jobs' icon.<br>
      <em>Example:</em> <code>true</code><br>
      <em>Example:</em> <code>false</code><br>
      <em>Example:</em> <code>"My reason"</code>
    </td>
  </tr>
</table>

## Grouping jobs by group identifier
 
The `group` step type not only groups up jobs and also groups them up by a `group_identifier` if it exists. For example:  
 
```yml 
steps:
  - command: "echo hello"
  - group: "hello group"
    steps:
      - command: "echo hello"
      - wait
      - command: "echo hello"
        parallelism: 3
  - group: ~
    steps:
      - command: "echo hello"
      - wait
      - command: "echo hello"
  - command: "echo goodbye"
    parallelism: 2
```
{: codeblock-file="pipeline.yml"}  

## Using parallel groups  

<!-- vale off --> 
Parallel groups will be displayed ungrouped if the build's jobs are truncated because Buildkite doesn't currently store or calculate any information about the number of jobs in a non-parallel group.

If a parallel step exists within a group, parallel jobs are treated as simple jobs within a step group - so you can't have parallel groups within step groups. So, for example, a `group` that contains two `steps` each with `parallel: 4` will display eight jobs in it, with no visual indication that those eight jobs are two parallel steps. 
<!-- vale on -->

## Limitations in job groups
 
There exist several limitations regarding the job groups' behavior:
 
* Only the first 100 jobs within a build header will be displayed, so you might not see all of your groups at all times. However, the jobs are fine and will still show up on the build page. 
* It's impossible to have a parallel job with only some of the jobs within a group, as they're all created on the same YAML step entry.
* Sub-groups and nested groups are not supported.
* If a parallel job group is within a named group, the groups are handled as though the parallel group isn't there.
 
## Using wait steps in job groups
 
You can have [wait steps]() in a group. Such steps operate independently of other groups. For example, both groups will operate independently here, meaning "d" won't wait on "a" to finish:
```yml
steps:
  - group: "111"
    depends_on: "tests"
    steps:
      - command: "a.sh"
      - wait
      - command: "b.sh"

  - group: "222"
    depends_on: "tests"
    id: "toast"
    steps:
      - command: "c.sh"
      - wait
      - command: "d.sh"

  - command: "yay.sh"
    depends_on: "toast"
```
{: codeblock-file="pipeline.yml"}

## Group merging  

Different droups that have the same name are merged together in the UI. 

For example, if you have a YAML file:

```yml
- group: "Setup"
  steps:
    - command: "buildkite agent pipeline upload"
```
{: codeblock-file="pipeline-01.yml"}

And this YAML file uploads a pipeline that has a group with the same name:

```yml
- group: "Setup"
  steps:
    - command: "docker build"
```yml
{: codeblock-file="pipeline-02.yml"}

As a result, the groups will be merged into one in the UI and the `"docker build"` step will be added to the existing group.

[image placeholder]

# Managing Pipeline Secrets

When you need to use secret values in your pipelines, there are some best practices you should follow to ensure they stay safely within your infrastructure, and are never sent to Buildkite.

<%= toc %>

## Using a secrets storage service

A best practice for secret storage is to use your own secrets storage service, such as [AWS Secrets Manager](https://aws.amazon.com/secrets-manager/) or [Hashicorp Vault](https://www.vaultproject.io).

There are various [Buildkite Plugins](https://buildkite.com/plugins) that integrate reading and exposing secrets to your build steps using secrets storage services.

## Storing secrets in environment hooks

If you don't use a secrets storage service, a recommended place to store secrets for your build scripts is in an [agent environment hook](/docs/agent/v3/hooks).

To do this, you create the required hook on your agent machine, add a conditional check to expose it only to the pipeline and step you require, and then `export` it into the build environment.

For example, say you had the following `scripts/trigger-github-deploy` file you wanted to run from a Buildkite pipeline called "My App":

```bash
#!/bin/bash
set -euo pipefail

curl \
  -H "Authorization: token $GITHUB_MY_APP_DEPLOYMENT_ACCESS_TOKEN" \
  -X POST \
  https://api.github.com/repos/my-org/my-app/deployments
```

To run this script, you'd create the following step in your a pipeline:

```yml
steps:
  - command: scripts/trigger-github-deploy
    id: trigger-github-deploy
```

To expose the `GITHUB_MYAPP_DEPLOYMENT_API_KEY` environment variable for this step, you would edit the [agent environment hook](/docs/agent/v3/hooks) on your agent machine to contain the following:

```bash
#!/bin/bash
set -euo pipefail

if [[ "$BUILDKITE_PIPELINE_SLUG" == "my-app" ]]; then
  if [[ "$BUILDKITE_STEP_IDENTIFIER" == "trigger-github-deploy" ]]; then
    export GITHUB_MY_APP_DEPLOYMENT_ACCESS_TOKEN="bd0fa963610b9364d2510e26de95b39b5ec6a107"
  fi
fi
```

By checking both the pipeline slug and the step identifier, you've ensured that only this step will get access to the value of the secret. It's important to add these conditional checks, because agent hooks are run for every build job on the agent machine.

## Storing secrets with the Elastic CI Stack for AWS

To store secrets when using the [Elastic CI Stack for AWS](https://github.com/buildkite/elastic-ci-stack-for-aws), you place them inside the encrypted S3 bucket that the stack creates for you. Unlike normal agent hooks, the Elastic CI Stack's hooks are per-pipeline.

For example, to expose a `GITHUB_MY_APP_DEPLOYMENT_ACCESS_TOKEN` environment variable to a step with id `trigger-github-deploy`, you would create the following `env` file on your local development machine:

```bash
#!/bin/bash
set -euo pipefail

if [[ "$BUILDKITE_STEP_IDENTIFIER" == "trigger-github-deploy" ]]; then
  export GITHUB_MY_APP_DEPLOYMENT_ACCESS_TOKEN="bd0fa963610b9364d2510e26de95b39b5ec6a107"
fi
```

You then upload the env file, encrypted, into the secrets bucket with the following command:

```bash
# Upload the env
aws s3 cp --acl private --sse aws:kms env "s3://elastic-ci-stack-my-stack-secrets-bucket/my-app/env"
# Remove the original file
rm env
```

See the [Elastic CI Stack for AWS](https://github.com/buildkite/elastic-ci-stack-for-aws) readme for more information and examples.

## Anti-pattern: Storing secrets in your pipeline settings

(insert words)

## Anti-pattern: Exposing secrets in pipeline uploads

One common anti-pattern is to expose secrets by referring to them directly in your pipeline.yml file, and having them interpolated during the `buildkite-agent pipeline upload` step. This results in the secret being uploaded to Buildkite, and should be avoided.

Here's an example showing a step that incorrectly refers to a secret environment variable:

```yml
steps:
  - command: |
      curl \
        # Security risk! The secret will be interpolated into the YML file and sent to Buildkite
        -H "Authorization: token $GITHUB_MY_APP_DEPLOYMENT_ACCESS_TOKEN" \
        -X POST \
        https://api.github.com/repos/my-org/my-app/deployments
```

This results in Buildkite being sent the value of the GitHub access token.

If you must define your command directly in the YML file, then you should ensure to escape any environment variables by using the `$$`:

```yml
steps:
  - command: |
      curl \
        # Not great! But by using $$ the value of the secret is never sent to Buildkite
        -H "Authorization: token $$GITHUB_MY_APP_DEPLOYMENT_ACCESS_TOKEN" \
        -X POST \
        https://api.github.com/repos/my-org/my-app/deployments
```

The best way to ensure secrets aren't exposed in pipeline uploads is to replace the command with a build script, for example:

```yml
steps:
  # Best practice. This avoids any reference to the secret in the pipeline.yml file
  - command: scripts/trigger-github-deploy
```

## Anti-pattern: Storing secrets in your pipeline.yml

(insert words)

```yml
env:
  # Security risk! The secret will be sent to Buildkite
  GITHUB_MY_APP_DEPLOYMENT_ACCESS_TOKEN: "bd0fa963610b9364d2510e26de95b39b5ec6a107"

steps:
  - command: scripts/trigger-github-deploy
```

## Anti-pattern: Storing secrets in build scripts

(insert words). Never sent to Buildkite, but just bad.

```yml
#!/bin/bash

curl \
  -H "Authorization: token bd0fa963610b9364d2510e26de95b39b5ec6a107" \
  -X POST \
  https://api.github.com/repos/my-org/my-app/deployments
```
# Managing Log Output

Buildkite uses our open-source [terminal Golang library](https://github.com/buildkite/terminal) to provide you with the best possible terminal rendering experience for your build logs, including ANSI terminal emulation to ensure spinners, progress bars, colors and emojis are rendered beautifully.

{:toc}

## Collapsing output

You can group and collapse your build output by echoing `--- [group name]` in your build output.

```bash
echo "--- A section of the build"
```

You can group, collapse and de-emphasize your build output by echoing `~~~ [group name]` in your build output.

```bash
echo "~~~ An unimportant section of the build"
```

If you want to have the group open by default, use `+++` instead:

```bash
echo "+++ A section of the build"
```

If no group is explicitly expanded (`+++`), then the last collapsed regular group (`---`) gets expanded instead. If you really want all groups to be collapsed, add an empty expanded group (`+++`).

If you'd like to open the previously defined group, use `^^^ +++`. This is useful if a command within a group fails, and you'd like to have the group already open when you view the log.

```bash
echo "--- Bundling"
bundle
if [[ $? -ne 0 ]]; then
  echo "^^^ +++"
  echo "Bundler failed, oh no!!"
fi
```

You can even include colors and emojis!

```bash
echo -e "--- Running \033[33mspecs\033[0m \:cow\:\:bell\:"
```

<%= image("collapsing_example.png", size: '261x127', alt: 'Screenshot of colored, emoji build output') %>

## Log output limits

If your build output exceeds 1MB then we'll only show the last 1MB of it in the rendered terminal output on your build page. In addition, your log file must not exceed 100MB else it may fail to upload.

If your log exceeds 1MB then we highly recommend reconfiguring your build tools to filter out unnecessary lines. Sometimes this isn't always possible, so you can use the below techniques to store and filter your log.

## Storing the original log

One method for storing the original log is the Unix `tee` command. It allows you to store the output stream of a command to a file and passing it straight through unchanged to the next command.

```bash
#!/bin/bash

set -euo pipefail

your_build_command | tee build.log | <filter command>
```
{: codeblock-file="build.sh"}

When this script is run it will store the original output of `your_build_command` to the file `build.log`.

To store this file alongside your build, add the `artifact_paths` attribute to the command step running your script:

```yaml
steps:
  - command: build.sh
    artifact_paths: "build.log"
```
{: codeblock-file="pipeline.yml"}

When your build is finished the agent will upload `build.log` as a build artifact, which will be downloadable from the "Artifacts" tab on your build page.

<%= image("large_build_log.png", alt: "Screenshot of build log available in the Artifacts tab", size: '511x241') %>

## Filtering with grep

Grep is a Unix tool to help you filter lines of text that match a pattern. For example, the following script only sends Buildkite the matching lines as your log output, whilst storing the original log for artifact uploading.

```bash
#!/bin/bash

set -euo pipefail

your_build_command | tee build.log | grep 'some pattern'
```

## Truncating with tail

Tail is a Unix tool that returns the last portion of a file. This is useful if your log output is exceeding our hard limit of 100MB. For example, the following script only sends Buildkite the last 90MB as your output log, whilst storing the original log for artifact uploading.

```bash
#!/bin/bash

set -euo pipefail

your_build_command | tee build.log | tail -c90000000
```

## Improving Xcode logs with xcpretty

[xcpretty](https://github.com/supermarin/xcpretty) is an open-source tool that helps to reduce, format and color-code your [Xcode](http://developer.apple.com/xcode) build output. Once youâ€™ve installed xcpretty you can pipe the output of xcodebuild into it:

```bash
#!/bin/bash

set -euo pipefail

xcodebuild <build options> | tee -a build.log | xcpretty -c
```

Make sure to set the `-o pipefail` option in your buildscript as above, otherwise the build failure status might not be passed through correctly.

<%= image("xcpretty.png", alt: "Screenshot of xcpretty output", size: '656x316') %>

## Encryption and security

Buildkite has zero access to your source code in the pipelines and only receives and stores the log output of the builds and build artifacts in encrypted form.

Logs are AES-encrypted, and the build artifacts are encrypted in transit and at rest using AWS encryption (KMS or S3 SSE). As a result, the keys cannot be extracted on the Buildkite's side, and the AWS solutions provide mitigations against zero-day attacks and other security issues. Beyond this, the control over security measures within your infrastructure is up to you.

If you choose to [host your build artifacts](/docs/agent/v3/cli-artifact#using-your-private-aws-s3-bucket) yourself, they end up in your private AWS bucket.

If you are a Buildkite Enterprise user, you can also set up a private AWS S3 build log archive location and store the logs in your private bucket.

To further tighten the security in a Buildkite organization, you can use the [API Access Audit](https://buildkite.com/organizations/~/api-access-audit) to track the actions of the users who have API Access Tokens that can access your organization's data using the REST and GraphQL API.

## Redacted environment variables

The Buildkite agent can redact the values of environment variables whose names match common patterns for passwords, and other secure information, before the build log is uploaded to Buildkite.

The default environment variable name patterns are `*_PASSWORD`, `*_SECRET` and `*_TOKEN`. You can replace the default patterns by [setting redacted-vars](/docs/agent/v3/configuration#redacted-vars) **on your agent**.

For example, if you have environment variable `MY_SECRET="topsecret"`and you run a command that outputs `This is topsecret info`, the log output will actually be `This is [REDACTED] info`.

<div class="Docs__note">
<h3 class="Docs__note__heading">Setting environment variables</h3>
<p>Note that if you <emphasis>set</emphasis> or <emphasis>interpolate</emphasis> a secret environment variable in your <code>pipeline.yml</code> it is not redacted, but doing that is <a href="/docs/pipelines/secrets#anti-pattern-storing-secrets-in-your-pipeline-dot-yml">not recommended</a>.</p>
</div>

## Private build log archive storage

By default, build logs are stored in encrypted form in Buildkite's Amazon S3 buckets, but you can also store the archived build logs in your private AWS S3 bucket.

<div class="Docs__note">
<p>This feature is only available to <a href="https://buildkite.com/pricing">Buildkite Enterprise</a> users.</p>
</div>

To set up a private build log archive storage:

1. Create an Amazon S3 bucket in *us-east-1* location (the only region that is currently supported).
2. Provide *read* and *write* access permission policy for the Buildkite's AWS account `032379705303`.

    Here's an example policy that contains an Amazon S3 bucket configuration with Buildkite's account number in it. Replace `my-bucket` and `my-prefix` placeholders with your Amazon S3 bucket information:

    ```json
    {
        "Version": "2012-10-17",
        "Statement": [
            {
                "Sid": "AllowBuildkiteToWriteObjectsInLogsPrefix",
                "Effect": "Allow",
                "Principal": {
                    "AWS": "arn\:aws\:iam::032379705303:root"
                },
                "Action": "s3:PutObject",
                "Resource": "arn\:aws\:s3:::my-bucket/my-prefix/*",
                "Condition": {
                    "StringEquals": {
                        "s3:x-amz-acl": "bucket-owner-full-control"
                    }
                }
            },
            {
                "Sid": "AllowBuildkiteToReadObjectsInLogsPrefix",
                "Effect": "Allow",
                "Principal": {
                    "AWS": "arn\:aws\:iam::032379705303:root"
                },
                "Action": "s3:GetObject",
                "Resource": "arn\:aws\:s3:::my-bucket/my-prefix/*"
            },
            {
                "Sid": "AllowBuildkiteToDeleteObjectsInLogsPrefix",
                "Effect": "Allow",
                "Principal": {
                    "AWS": "arn\:aws\:iam::032379705303:root"
                },
                "Action": "s3:DeleteObject",
                "Resource": "arn\:aws\:s3:::my-bucket/my-prefix/*"
            },
            {
                "Sid": "AllowBuildkiteToListBucketInLogsPrefix",
                "Effect": "Allow",
                "Principal": {
                    "AWS": "arn\:aws\:iam::032379705303:root"
                },
                "Action": "s3:ListBucket",
                "Resource": "arn\:aws\:s3:::my-bucket",
                "Condition": {
                    "StringLike": {
                        "s3:prefix": "my-prefix/*"
                    }
                }
            }
        ]
    }
    ```

3. Reach out to [success@buildkite.com](mailto:success@buildkite.com) and provide the address of your Amazon S3 bucket. The Buildkite engineering team will continue the configuration to complete the setup.

## Links & images in log output

You can embed links, external images, and images generated by your builds directly into your logs using special ANSI escape codes.

ANSI escape codes are used for many tasks in UNIX terminals, such as setting text color uses an ANSI escape code. Buildkite supports most standard ANSI escape codes and a few special ones, thanks to our terminal output processor, [`terminal-to-html`](https://github.com/buildkite/terminal-to-html).

### Links

You can embed clickable links to Buildkite or other web pages by using ANSI escape code `1339`.

The following Bash function takes a URL and optional link text and will output the correct escape code sequence:

```bash
function inline_link {
  LINK=$(printf "url='%s'" "$1")

  if [ $# -gt 1 ]; then
    LINK=$(printf "$LINK;content='%s'" "$2")
  fi

  printf '\033]1339;%s\a\n' "$LINK"
}
```

You can use it like so:

```bash
inline_link 'https://buildkite.com/'
```

Or, to use a custom label:

```bash
inline_link 'https://buildkite.com/' 'Buildkite'
```

You can also link to an uploaded artifact by using the `artifact://` URL syntax:

```bash
inline_link 'artifact://tmp/images/omg.gif'
```

### Inlining images

The syntax for inlining images uses ANSI escape code `1338`. A `url` is required, and you can optionally specify an `alt` attribute to describe what the image is.

The following Bash function takes an image URL and alternative text and will output the correct escape code sequence:

```bash
function inline_image {
  printf '\033]1338;url='"$1"';alt='"$2"'\a\n'
}
```

You can use it like so:

```bash
inline_image 'https://media0.giphy.com/media/8Ry7iAVwKBQpG/giphy.gif' 'Rainbows'
```

When rendered in Buildkite (using our open-source [Terminal tool](http://buildkite.github.io/terminal-to-html/)) it will look like this:

<%= image("external_image.png", size: '598x410') %>

When you run the script locally you won't see any output because your terminal will ignore the escape code. If you pipe your build script to `more` you can see the raw escape codes.

#### Inlining build artifact images

You can inline artifact images by using the `artifact://` URL syntax. For example you can inline the following artifact:

<%= image("artifact_path.png", size: '228x140') %>

by using the following URL:

```bash
inline_image 'artifact://tmp/images/omg.gif' 'OMG'
```

Be careful to ensure the part of the URL after `artifact://` exactly matches the path you see in the Artifacts tab (for example, it can't have a preceding `./`).

The image artifact does not have to be uploaded at the time it's written to the build log. If the artifact has not been uploaded you'll see a loading placeholder, and as soon as it's ready the image will automatically appear.

<section class="Docs__note">
  <p>If you are using private artifacts, your images need to be base64-encoded so that Buildkite can access and inline them.</p>
</section>

### Inlining base64-encoded images

If you want to embed an image encoded in base64, you can use [iTerm's image format](http://iterm2.com/images.html#/section/home), but be mindful of the [log output limits](/docs/pipelines/managing-log-output#log-output-limits). Unless you're embedding images for a specific reason, it's better to upload the image as a [build artifact](/docs/pipelines/artifacts#uploading-artifacts-in-build-steps) and reference it using the `artifact://` URL.

### Library support for inlining screenshots and other images

* The [capybara-inline-screenshot](https://github.com/buildkite/capybara-inline-screenshot) Ruby gem will automatically inline screenshots of your integration test failures and also supports the iTerm image format for viewing failures directly in your terminal. When run under CI it automatically uses the `artifact://` URL format.
<br>
<%= image("ruby_gem.png", size: '806x387') %>

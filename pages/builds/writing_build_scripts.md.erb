# Writing Build Scripts

Steps in your build pipelines are most often just shell scripts that are checked in alongside your code. The [Buildkite Agent](/docs/agent) will run your scripts, capture and report the log output, and use the exit status to mark the build as passed or failed.

<%= toc %>

## Configuring Bash

The shell that runs your scripts in Buildkite is a clean bash prompt with no settings. If you rely on anything from your bashprofile or bashrc files when you run scripts locally, you'll need to explicitly add the relevant items to your build scripts.   
There are four Bash options which are often used in build scripts:

<table>
  <tbody>
  <tr>
    <th><code>-e</code></th>
    <td>Exit immediately if a command exits with a non-zero status</td>
  </tr>
  <tr>
    <th><code>-u</code></th>
    <td>Exit immediately if an undefined variable is used (e.g. <code>echo "$UNDEFINED_ENV_VAR"</code>)</td>
  </tr>
  <tr>
    <th><code>-o pipefail</code></th>
    <td>Ensures pipelines (e.g. <code>cmd | othercmd</code>) return a non-zero status if a command fails</td>
  </tr>
  <tr>
    <th><code>-x</code></th>
    <td>Print each expanded command before executing (useful for debugging)</td>
  </tr>
  </tbody>
</table>

Most build scripts should set the `-e` and `-o pipefail` options to ensure if any command fails your entire build script fails. For example:

```bash
#!/bin/bash

set -eo pipefail

run_my_tests
```

If you need to perform tasks after your main command executes then `set -e` might not be suitable, as any failure will cause the script to immediately exit and subsequent commands to be skipped. Instead of using `set -e` you’ll need to [capture the exit status](#capturing-exit-status) of your command yourself.

## Debugging your environment

The first step to debugging script is to output the environment. This will show any [environment variables set up by the Buildkite Agent](/docs/builds/environment-variables), as well as other important environment variables such as `$PATH`.

To add the environment to your build output simply execute `env` at the start of your build script.

```
#!/bin/bash

env
```

You can also set the `-x` option which will print out each command, fully expanded, before executing it.

```
#!/bin/bash

set -x
```

## Capturing Exit Status

If you want to execute commands after your main command, but still report success/fail correctly, you’ll need to capture the exit status of your main command and then exit with it at the end.

```bash
#!/bin/bash

run_my_tests

# Capture the exit status of the last command in a variable
ORIGINAL_STATUS=$?

# Additional commands

# Finish with the original status
exit $ORIGINAL_STATUS
```

## Managing Log Output

If you are getting too much logging in your build output, there are several strategies you can employ to reduce it. Take a look at our guide to [managing log output](/docs/builds/managing-log-output) for a step by step introduction. 

## Help Tools - Linting and Debugging

To check your shell scripts for common errors and mistakes you can use a linting tool like [Shellcheck](http://www.shellcheck.net). [Shellcheck](http://www.shellcheck.net) is a shell script linter with a web-based front-end and a command line tool. It can also be used directly in your code editor.

If you’re wanting to understand a particular piece of shell code [explainshell.com](http://explainshell.com) ([github.com/idank/explainshell](https://github.com/idank/explainshell)) can tell you, in plain English, what a line of code does. It also integrates the man pages of common tools such as `ssh` and `git`.

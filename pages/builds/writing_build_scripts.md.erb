# Writing Build Scripts

One of the most common actions that Buildkite pipeline steps perform is running a shell script. These scripts are checked in alongside your code and `pipeline.yml` file. The [Buildkite Agent](/docs/agent) will run your scripts, capture and report the log output, and use the exit status to mark each job, as well as the overall build, as passed or failed.

<%= toc %>

## Configuring Bash

The shell that runs your scripts in Buildkite is a clean bash prompt with no settings. If you rely on anything from your `~/.bash_profile` or `~/.bashrc` files when you run scripts locally, you'll need to explicitly add the relevant items to your build scripts.

There are a number of Bash options which can be useful to prevent unexpected errors:

<table>
  <tbody>
  <tr>
    <th><code>-e</code></th>
    <td>Exit script immediately if a command exits with a non-zero status.</td>
  </tr>
  <tr>
    <th><code>-u</code></th>
    <td>Exit script immediately if an undefined variable is used (e.g. <code>echo "$UNDEFINED_ENV_VAR"</code>).</td>
  </tr>
  <tr>
    <th><code>-o pipefail</code></th>
    <td>Ensures bash pipelines (e.g. <code>cmd | othercmd</code>) return a non-zero status if any of the commands fail, rather than only the exit code of the last command in the pipeline.</td>
  </tr>
  <tr>
    <th><code>-x</code></th>
    <td>Expand and print each command before executing. See <a href="/docs/builds/writing-build-scripts#debugging-your-environment">Debugging your environment</a> for more information. </td>
  </tr>
  </tbody>
</table>

To enable options use the `set` built-in Bash command, for example:

```bash
#!/bin/bash

# Enables the most common set of options for build scripts
set -euo pipefail

run_tests
```

For a full list of options, see the [Bash Reference Manual](https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html).

## Capturing Exit Status

Scripts often contain commands that shouldn't affect the overall exit status. For example, take the following script:

```bash
#!/bin/bash

run_tests
clean_up
``` 

Running this script will exit with the status returned by the final command `clean_up`. However, what we really care about is the outcome of the `run_tests` commmand.

Using a variable to store the exit status (`$?`) of the test script, we can run our other commands but still return the exit status of the original `run_tests` command:

```bash
#!/bin/bash

run_tests

# Capture the exit status of the last command in a variable
TEST_STATUS=$?

# Additional commands
clean_up

# Finish with the status of the tests command
exit $TEST_STATUS
```

Using this technique gives you complete control over the exit code of your script, and the final success/failure of your build job.

## Managing Log Output

If you are getting too much logging in your build output, there are several strategies you can employ to reduce it. Take a look at our guide to [managing log output](/docs/builds/managing-log-output) for a step by step introduction. 

## Debugging your environment

The first step in debugging your build script is to view the environment variables from the Buildkite web interface:

<%= image "viewing-job-environment-variables.png", width: 1044/2, height: 542/2, alt: 'Screenshot of viewing a job’s environment tab' %>

In addition, you can modify you build step to pring `$PATH` and any other important environment variables, before the main command you’re wanting to run. For example:

```bash
#!/bin/bash

echo $PATH

some_command
```

As a last resort you can execute `env`, which will print out all the environment variables. You should ensure you filter the output, using a tool such as `grep` or `egrep`, so you don't leak private keys or secrets that you have exposed.

For example, the following outputs all environent variables containing the word "git" or "node":

```bash
#!/bin/bash

env | egrep --ignore-case 'git|node'

some_command
```

<section class="Docs__troubleshooting-note">
  <h1>Security recommendation</h1>
  <p>If you use environment variables to define sensitive data, such as API keys, you should always filter the output of <code>env</code> to ensure you’re not exposing any secrets in your build log.</p>
</section>

You can also set the `-x` option which will execute all subequent commands in 'debug' mode. This will step through the script and print a line for each operation it performs. If you'd like to debug some commands but not others, you can turn debugging off again with `set +x`.  

```bash
#!/bin/bash

set -x
some_command
set +x

some_other_command
```

For more information about the `-x` option and debugging in general, see the [Bash Guide for Beginners' page on debugging bash scripts](http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_02_03.html).

## Help Tools - Linting and Debugging

To check your shell scripts for common errors and mistakes you can use a linting tool like [Shellcheck](http://www.shellcheck.net). [Shellcheck](http://www.shellcheck.net) is a shell script linter with a web-based front-end and a command line tool. It can also be used directly in your code editor.

For an explanation of a shell code snippet, the [explainshell.com](http://explainshell.com) tool is extremely useful. [Explainshell]](https://github.com/idank/explainshell)) can tell you, in plain English, what a line of code does. It also integrates the man pages of common tools such as `ssh` and `git`.


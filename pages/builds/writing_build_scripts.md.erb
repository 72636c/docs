# Writing Build Scripts
One of the most popular actions that Buildkite pipeline steps perform is running a shell script. These scripts are checked in alongside your code and `pipeline.yml` file. The [Buildkite Agent](/docs/agent) will run your scripts, capture and report the log output, and use the exit status to mark each job, as well as the overall build, as passed or failed.

<%= toc %>

## Configuring Bash

The shell that runs your scripts in Buildkite is a clean bash prompt with no settings. If you rely on anything from your bashprofile or bashrc files when you run scripts locally, you'll need to explicitly add the relevant items to your build scripts.   
There are four Bash options which are often used in build scripts:

<table>
  <tbody>
  <tr>
    <th><code>-e</code></th>
    <td>Exit immediately if a command exits with a non-zero status</td>
  </tr>
  <tr>
    <th><code>-u</code></th>
    <td>Exit immediately if an undefined variable is used (e.g. <code>echo "$UNDEFINED_ENV_VAR"</code>)</td>
  </tr>
  <tr>
    <th><code>-o pipefail</code></th>
    <td>Ensures pipelines (e.g. <code>cmd | othercmd</code>) return a non-zero status if a command fails</td>
  </tr>
  <tr>
    <th><code>-x</code></th>
    <td>Print each expanded command before executing (useful for debugging)</td>
  </tr>
  </tbody>
</table>

In the majority of cases, you will want to ensure that if any one command fails your entire build script fails. You can set up your script to do this automatically by using the `-e` and `-o pipefail` options. For example:

```bash
#!/bin/bash

set -eo pipefail

run_my_tests
```

However, if you need to perform tasks after your main command executes (regardless of success or failure), you’ll need to [capture the exit status](#capturing-exit-status) of your command yourself instead of using `set -e`.

## Capturing Exit Status

If you want to execute commands after your main command, but still report success/fail correctly, you’ll need to capture the exit status of your main command and then exit with it at the end.

```bash
#!/bin/bash

run_my_tests

# Capture the exit status of the last command in a variable
ORIGINAL_STATUS=$?

# Additional commands

# Finish with the original status
exit $ORIGINAL_STATUS
```

## Managing Log Output

If you are getting too much logging in your build output, there are several strategies you can employ to reduce it. Take a look at our guide to [managing log output](/docs/builds/managing-log-output) for a step by step introduction. 

## Debugging your environment

The first step in debugging your build script is outputting the environment information. This will show any [environment variables](/docs/builds/environment-variables) set up by the Buildkite Agent, as well as other important environment variables such as `$PATH`.

To add the environment to your build output execute `env` at the start of your build script.

```
#!/bin/bash

env
```

You can also set the `-x` option which will execute all subequent commands in 'debug' mode. This will step through the script and print a line for each operation it performs. If you'd like to debug some commands but not others, you can turn debugging off again with `set +x`.  

```
#!/bin/bash

set -x
tests.sh
set +x

run.sh
```

For more information about the `-x` option and debugging in general, see the [Bash Guide for Beginners' page on debugging bash scripts](http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_02_03.html).

## Help Tools - Linting and Debugging

To check your shell scripts for common errors and mistakes you can use a linting tool like [Shellcheck](http://www.shellcheck.net). [Shellcheck](http://www.shellcheck.net) is a shell script linter with a web-based front-end and a command line tool. It can also be used directly in your code editor.

If you’re wanting to understand a particular piece of shell code [explainshell.com](http://explainshell.com) ([github.com/idank/explainshell](https://github.com/idank/explainshell)) can tell you, in plain English, what a line of code does. It also integrates the man pages of common tools such as `ssh` and `git`.

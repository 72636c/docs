# Parallel Builds

Running a build's jobs in parallel is a simple technique to decrease your build’s total running time. This guide will show you how to use multiple agents and job parallelism to increase the speed of your builds.

<%= toc %>

## Running multiple agents

<section class="Docs__note">
    <p>There are two techniques for scaling your build agents: horizontally across multiple machines, or vertically on a single machine. For the sake of simplicity, the following example shows vertically scaling your agents on a single machine. For details on horizontal scaling, which allows for running hundreds or thousands of build agents, see the <a href="#auto-scaling-your-build-agents">auto-scaling your build agents</a> section.</p>
</section>

The steps for running multiple agents are slightly different for each platform. Automated installers and detailed instructions can be found in the [installation](/docs/agent/installation) section. For this example we'll use a [Ubuntu-based build agent](/docs/agent/ubuntu) to start 5 instances of the Buildkite agent:

```bash
# After running the standard install instructions...

sudo cp /etc/init/buildkite-agent.conf /etc/init/buildkite-agent-2.conf
sudo service buildkite-agent-2 start

sudo cp /etc/init/buildkite-agent.conf /etc/init/buildkite-agent-3.conf
sudo service buildkite-agent-3 start

sudo cp /etc/init/buildkite-agent.conf /etc/init/buildkite-agent-4.conf
sudo service buildkite-agent-4 start

sudo cp /etc/init/buildkite-agent.conf /etc/init/buildkite-agent-5.conf
sudo service buildkite-agent-5 start
```

## Parallel Jobs

To run the same step in parallel over all 5 of the agents, we can set the `parallelism` field for a single build step:

<%= image 'parallelism.png', size: '555x138', alt: 'Step parallelism field' %>

Update the name of the step to use `%n`, like the example below. This will substitute a number in at runtime so that you can differentiate the different build jobs:

<%= image 'name.png', size: '555x80', alt: 'Step name field with %n' %>

Now that the pipeline is configured, create a new build:

<%= image 'build.png', size: '405x204', alt: 'The build' %>

If you inspect the first job’s environment variables you’ll find:

```
BUILDKITE_PARALLEL_JOB=0
BUILDKITE_PARALLEL_JOB_COUNT=5
```

The `BUILDKITE_PARALLEL_JOB` environment variable stores the job number starting from 0. In this case each job’s value would be `0`, `1`, `2`, `3`, and `4` respectively.

The `BUILDKITE_PARALLEL_JOB_COUNT` environment variable stores the total number of jobs created from this step for this build.

You can use these two environment variables to divide your application’s tests between the different jobs.

## Libraries

* [Knapsack](https://github.com/ArturT/knapsack)
<br>A ruby gem for that will automatically divide your tests between parallel jobs, as well as making sure each job runs in comparable time. Supports RSpec, Cucumber, Minitest, Spinach and Turnip.

* [Knapsack Pro](https://github.com/KnapsackPro/knapsack_pro-ruby)
<br>A commercially supported version of Knapsack that provides a hosted service for test timing data and additional job distribution modes. See the [documentation](https://github.com/KnapsackPro/knapsack_pro-ruby#info-for-buildkitecom-users) and [step-by-step tutorial](http://docs.knapsackpro.com/2017/auto-balancing-7-hours-tests-between-100-parallel-jobs-on-ci-buildkite-example) for setup instructions and example pipelines.

## Isolated jobs

You can safely run multiple agents on a single machine, though you’ll still need to ensure your application’s code is able to be run in parallel. One convenient way of doing this is by using the agent’s [built in Docker and Docker Compose support](docker-containerized-builds) which will run each job in one or more completely isolated containers.

## Auto-scaling your build agents

We provide a number of APIs for automatically scaling agents based on you build queue.

* Using the [Pipelines API](/docs/api/pipelines) you’re able to fetch the `scheduled_jobs_count`, `waiting_jobs_count` and `running_jobs_count` to get an overview of the number of jobs waiting to be run. Keeping track of this value, you can spin new agent machines up or down to accomodate the job load.
* Using [agent prioritization](/docs/agent/prioritization) you’ll able to define which agents are assigned work first, as well as lower priority agents which you may spin up and down on demand.
* Using the [Agents API](/docs/api/agents) you’re able to fetch your agent’s `job` and `last_job_finished_at`, which allow you to see if they have been idle. Using the [agent stop API](/docs/api/agents#stop-an-agent) you can remotely shut down idle agent processes (passing `"force": false` to ensure it won’t cancel any running job).

Using these three APIs you can automate your build infrastructure, scale your agents based on demand, and ensure no-one has to wait for their build to start.

# Deployments with Buildkite

There are many ways to set up both manual and continuous deployment workflows using Buildkite.

For more detailed platform-specific deployment guides, see the [Heroku](/docs/deployments/deploying-to-heroku) and [Kubernetes](/docs/deployments/deploying-to-kubernetes) guides. 

<%= toc %>

## Single deployment steps

Adding a deployment step that runs after your tests pass is the simplest way to deploy from a Buildkite pipeline.

The example `pipeline.yml` below shows how to set up deployment using a single step that runs after the tests pass. It uses [step-level branch filtering](/docs/pipelines/branch-configuration#step-level-branch-filtering) to perform continuous deployment on `master` branch builds, and uses [concurrency limiting](/docs/pipelines/controlling-concurrency) to ensure only one deployment runs at a time.

```yml
steps:
  - label: ":hammer:"
    command: "scripts/test"
  
  - wait
  
  - label: ":rocket:"
    command: "scripts/deploy"
    branches: "master"
    concurrency_group: "my-app-deploy"
    concurrency_limit: 1
```

<screenshot of a deploy step>

## Dedicated deployment pipelines

A dedicated deployment pipeline separates your deploy steps from any other testing and building steps. 

Creating deployment pipelines makes it easier to:

* Separate deployment failures from test failures
* Separate test and deployment pipeline.yml files
* Re-run failed deployments
* Simplify adding rollback steps
* Group other deploy-related tasks with the deployment steps
* Use teams for role based access control
* Whitelist deploy pipelines in agent hooks

For example, the following "My App" test pipeline will trigger a build on the "my-app-deployment" pipeline whenever a test build passes on `master`:

```yml
steps:
  - label: ":hammer:"
    command: "scripts/test"

  - wait

  - label: ":rocket:"
    trigger: "my-app-deployment"
    branches: "master"
```

The deployment pipeline is configured to pipeline upload the following  file:

The "my-app-deployment" pipeline below is defined in the `.buildkite/pipeline.deploy.yml` file, and will run the `deploy` script when a build is triggered by the "my-app-test" pipeline above. 

```yml
steps:
  - label: ":rocket:"
    command: "scripts/deploy"
    branches: "master"
    concurrency_group: "my-app-deploy"
    concurrency_limit: 1
```

The ":rocket:" step in the deployment example above uses the concurrency attributes `concurrency_group` and `concurrency_limit`. These work together to ensure that no matter how many builds are triggered on this pipeline at once, no ":rocket:" steps can run in parallel. It also prevents deploys clashing and attempting to write to the same resources. 

<screenshot of a deploy pipeline>

## Manual approval steps

Adding a manual approval to your pipeline before your deployment ensures that a deploy never goes out without explicit approval.

To create a manual approval for your deploy, add a block step before your deploy step or before the step that triggers your deploy pipeline. 

The below example uses the same pipeline as the [Single deployment step](/docs/deployments#single-deployment-step) section, but adds a block step before the step that performs the deploy:

```
steps:
  - label: ":hammer:"
    command: "scripts/test"
  
  - block: "Unblock deployment?"
  
  - label: ":rocket:"
    command: "scripts/deploy"
    branches: "master"
    concurrency_group: "my-app-deploy"
    concurrency_limit: 1
```

Until the block step is manually unblocked either in Buildkite or via an API call, the build will be paused and the ":rocket:" deployment step will not run.

## External deployment systems

As well as writing deployment scripts, you can use any external systems alongside Buildkite to perform your deployments.

You can deploy images or containers to services like Kubernetes, Heroku, ECS, or Github Deployments. Deploy your containers directly from a script in a Buildkite command step using either the single deploy step pattern or the dedicated pipeline pattern discussed above.

For a more detailed walk-through with examples, we have deployment guides for [Heroku](/docs/deployments/deploying-to-heroku) and [Kubernetes](/docs/deployments/deploying-to-kubernetes). 

- there are [plugins](/docs/pipelines/plugins) available for deployments: [ECS deploy] and [lambda deploy]
- use these in place of scripts to perform your deploys, they have inbuilt params to send all of the data you need to deploy

- the below code is an example of a dedicated pipeline to deploy an image to ECS
- it would be triggered by a pipeline that performed other actions like running tests and building the image
- a block step holds the deploy off until it is unblocked via Buildkite or a call to the REST API or GraphQL API. 
- the deploy step takes the prebuilt image that had been pushed to ECR when it was built
- the image is named using the commit from the build that built the image, the triggering build passes through the commit number in the `BUILDKITE_COMMIT` environment variable 
- the task definition specified is used to deploy the image to ECS

```
steps:
  - block: "Release to production?"
  - label: ":ecs: :rocket:"
    concurrency_group: "rails-app-deploy"
    concurrency: 1
    plugins:
      - ecs-deploy#v1.3.0:
        cluster: "production"
        service: "app"
        task-definition: "production-deploy/rails-app.json"
        task-family: "rails-app"
        image: "${ECR_REPOSITORY}/rails-app:${BUILDKITE_COMMIT}"
        task-role-arn: "deployer"
        deployment-configuration: "100/200"
```

Check out the [plugins directory](https://buildkite.com/plugins) for newly added deployment plugins. If there's no plugin for your deployment service of choice, we'd love it if you added one! 

For more complex environments, you can use continuous deployment services like Spinnaker, Shipit, or Samson. As with container-based external deployment systems, you can create a step in your Buildkite pipeline to trigger your deployment in your CD service.  






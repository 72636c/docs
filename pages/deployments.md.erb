# Deployments with Buildkite

There are many ways to set up both manual and continuous deployment workflows using Buildkite.

For more detailed platform-specific deployment guides, see the [Heroku](/docs/deployments/deploying-to-heroku) and [Kubernetes](/docs/deployments/deploying-to-kubernetes) guides. 

<%= toc %>

## Single deployment steps

Adding a deployment step that runs after your tests pass is the simplest way to deploy from a Buildkite pipeline.

The example `pipeline.yml` below shows how to set up deployment using a single step that runs after the tests pass. It uses [step-level branch filtering](/docs/pipelines/branch-configuration#step-level-branch-filtering) to perform continuous deployment on `master` branch builds, and uses [concurrency limiting](/docs/pipelines/controlling-concurrency) to ensure only one deployment runs at a time.

```yml
steps:
  - label: ":hammer:"
    command: "scripts/test"
  
  - wait
  
  - label: ":rocket:"
    command: "scripts/deploy"
    branches: "master"
    concurrency_group: "my-app-deploy"
    concurrency_limit: 1
```

<screenshot of a deploy step>

## Dedicated deployment pipelines

A dedicated deployment pipeline separates your deploy steps from any other testing and building steps. 

Creating deployment pipelines makes it easier to:

* Separate deployment failures from test failures
* Separate test and deployment pipeline.yml files
* Re-run failed deployments
* Simplify adding rollback steps
* Group other deploy-related tasks with the deployment steps
* Use teams for role based access control
* Whitelist deploy pipelines in agent hooks

For example, the following "My App" test pipeline will trigger a build on the "my-app-deployment" pipeline whenever a test build passes on `master`:

```yml
steps:
  - label: ":hammer:"
    command: "scripts/test"

  - wait

  - label: ":rocket:"
    trigger: "my-app-deployment"
    branches: "master"
```

The deployment pipeline is configured to pipeline upload the following  file:

The "my-app-deployment" pipeline below is defined in the `.buildkite/pipeline.deploy.yml` file, and will run the `deploy` script when a build is triggered by the "my-app-test" pipeline above. 

```yml
steps:
  - label: ":rocket:"
    command: "scripts/deploy"
    branches: "master"
    concurrency_group: "my-app-deploy"
    concurrency_limit: 1
```

The ":rocket:" step in the deployment example above uses the concurrency attributes `concurrency_group` and `concurrency_limit`. These work together to ensure that no matter how many builds are triggered on this pipeline at once, no ":rocket:" steps can run in parallel. This prevents deploys clashing and attempting to write to the same resources. 

<screenshot of a deploy pipeline>

## Gated deployments



## External deployment systems

- can use any external systems alongside buildkite to perform your deployments

- deploy images or containers to services like kubernetes, heroku, ecs, and github deployments
- can deploy your containers directly from a buildkite command step using either the single deploy step or the dedicated pipeline patterns discussed above

- there are [plugins](/docs/pipelines/plugins) available for deployments: [ECS deploy] and [lambda deploy]
- use these in place of scripts to perform your deploys, they have inbuilt params to send all of the data you need to deploy

- the below code is an example of a dedicated pipeline to deploy an image to ECS
- it would be triggered by a pipeline that performed other actions like running tests and building the image
- a block step holds the deploy off until it is unblocked via Buildkite or a call to the REST API or GraphQL API. 
- the deploy step takes the prebuilt image that had been pushed to ECR when it was built
- the image is named using the commit from the build that built the image, the triggering build passes through the commit number in the `BUILDKITE_COMMIT` environment variable 
- the task definition specified is used to deploy the image to ECS

```
steps:
  - block: "Release to production?"
  - label: ":ecs: :rocket:"
    concurrency_group: "rails-app-deploy"
    concurrency: 1
    plugins:
      - ecs-deploy#v1.3.0:
        cluster: "production"
        service: "app"
        task-definition: "production-deploy/rails-app.json"
        task-family: "rails-app"
        image: "${ECR_REPOSITORY}/rails-app:${BUILDKITE_COMMIT}"
        task-role-arn: "deployer"
        deployment-configuration: "100/200"
```

- check out the [plugins directory](https://buildkite.com/plugins), if there's no plugin for your deployment service of choice, add one!

- can also use continuous deployment services like spinnaker, shipit, or samson (cd, specific rules for how to deploy your stuff) create a step to trigger a deployment from your buildkite pipeline 





